import random  # randomizing bomb placement
import ansi    # coloring on the terminal
import os      # to clear up the terminal

# for recursive settings (in Python, the maximum recursive runs may not be the same)
sys = pyimport('sys')

RECURSION_LIMIT = 5_000  # how many recursive functions can be performed
CELL_SIZE = (20, 10)     # board size
BOMBS_COUNT = 30         # number of bombs
CELL_COLORS = {
    1:  (50 ,50 ,200),
    2:  (50 ,200,50 ),
    3:  (200,50 ,50 ),
    4:  (252,140,3  ),
    5:  (98 ,3  ,252),
    6:  (150,50 ,150),
    7:  (43 ,19 ,25 ),
    8:  (25 ,25 ,25 ),
    9:  (255,0  ,0  ),  # bomb
    10: (200,20 ,20 )   # flag
}

FLAG_COLOR = ansi.acolor(CELL_COLORS[10], ansi.BACKGROUND | ansi.BOLD | ansi.ITALIC)
BOMB_COLOR = ansi.acolor(CELL_COLORS[9], ansi.BACKGROUND)

sys.setrecursionlimit(RECURSION_LIMIT)

# clear up screen
if (os.name == 'nt')
    func clear() => os.system('cls')
else
    func clear() => os.system('clear')

class MineSweeper {

    func __init__(self, cellSize, bombsCount) {
        if (not isinstance(cellSize, (tuple, list)))
            throw TypeError("MineSweeper(): cellSize must be tuple or list")
        if (not isinstance(bombsCount, int))
            throw TypeError("MineSweeper(): bombsCount must be integer")

        if (len(cellSize) != 2)
            throw ValueError("MineSweeper(): cellSize must have a length of 2")

        w, h = cellSize

        if (not isinstance(w, int))
            throw TypeError("MineSweeper(): width must be integer")
        if (not isinstance(h, int))
            throw TypeError("MineSweeper(): height must be integer")

        if (w < 1)
            throw ValueError("MineSweeper(): width must be greater than 1")
        if (h < 1)
            throw ValueError("MineSweeper(): height must be greater than 1")

        totalCell = w * h

        if (bombsCount >= totalCell)
            throw ValueError("MineSweeper(): bombsCount cannot more than {}".format(totalCell))

        self.cellSize = cellSize
        self.bombsCount = bombsCount
    }

    # create empty dug, flags and board
    func makeNewEmptyBoard(self) {
        w, h = self.cellSize

        self.dug = set()
        self.flags = set()
        self.board = list(
            comprehension(
                range(h),
                func(i) => list(
                    comprehension(
                        range(w),
                        func(i) => 0
                    )
                )
            )
        )
    }

    # create a new board (the makeNewEmptyBoard function should have been called)
    func makeNewBoard(self, position) {
        w, h = self.cellSize
        col, row = position

        # STEP 1: position the bomb

        # the starting position of the player should be chosen as the section where there should be no bombs to avoid
        # losing at the start of the game
        illegalXMin, illegalYMin = max(0, col - 1), max(0, row - 1)
        illegalXMax, illegalYMax = min(w, col + 2), min(h, row + 2)

        # place bombs randomly on the board
        bombsPlanted = 0

        while (bombsPlanted < self.bombsCount) {
            col = random.randint(0, w - 1)
            row = random.randint(0, h - 1)

            # if there is already a bomb in this position or the position is close to the initial position the player
            # chooses, then continue selecting another bomb location
            if (self.board[row][col] == 9 or (illegalXMin <= col <= illegalXMax and illegalYMin <= row <= illegalYMax))
                continue

            # place bomb
            self.board[row][col] = 9
            bombsPlanted++
        }

        # STEP 2: determines the value of the number of bombs in the 3x3 area in each cell

        for (row of range(h)) {
            for (col of range(w)) {
                # cell are bomb
                if (self.board[row][col] == 9)
                    continue

                # STEP 3: determine the number of bombs around the 3x3 area
                number = 0

                for (r of range(max(0, row - 1), min(h, row + 2))) {
                    for (c of range(max(0, col - 1), min(w, col + 2))) {
                        # is a middle cell
                        if (col == c and r == row)
                            continue

                        # if there is a bomb
                        if (self.board[r][c] == 9)
                            number++
                    }
                }

                # set the cell value
                self.board[row][col] = number
            }
        }
    }

    # dig a cell and determine whether chooses a cell containing a bomb or not
    func dig(self, position, _recursive=false) {
        w, h = self.cellSize
        col, row = position

        # if the cell is marked with a flag then it is safe without doing anything
        if (position in self.flags)
            return true

        cell = self.board[row][col]

        # if the cell is a bomb, then lose
        if (cell == 9)
            return false

        # chording mechanism
        chording = false

        if (
            # not for recursive
            not _recursive and

            # not for marked with a flag
            position not in self.flags and

            # cell have been dug
            position in self.dug and

            # cell value is must be between 1 to 7 (8 is not included because all neighbor cells are bombs)
            0 < cell < 8
        ) {
            # count the number of flags in a 3x3 area
            count = 0

            for (r of range(max(0, row - 1), min(h, row + 2))) {
                for (c of range(max(0, col - 1), min(w, col + 2))) {
                    if ((c, r) in self.flags)
                        count++
                }
            }

            # if the cell marked with the flag has the same number as this cell value, then chording is active
            chording = cell == count
        }

        # save dig position
        self.dug.add(position)

        # if sell is a number then it is safe without doing recursion (except if chording is active)
        if (cell > 0 and not chording)
            return true

        # dig recursive 3x3 area
        for (r of range(max(0, row - 1), min(h, row + 2))) {
            for (c of range(max(0, col - 1), min(w, col + 2))) {
                pos = (c, r)

                # the marked position is dug
                if (pos in self.dug)
                    continue

                safe = self.dig(pos, _recursive=true)

                # if the cell is a bomb, then lose
                if (not safe)
                    return false
            }
        }

        # everything is successful and safe
        return true
    }

    # set the flag position (toggle)
    func setFlag(self, position) {
        col, row = position

        # if the position has been dug
        if (position in self.dug)
            return;

        # toggle flag
        if (position in self.flags)
            self.flags.remove(position)
        else
            self.flags.add(position)
    }

    # displays the board
    func showBoard(self, safe=none) {
        w, h = self.cellSize

        buffer = '\x1b[J\x1b[H'
        separator = '---+' * w
        columnNumber = '    {} '.format(
            ' '.join(
                map(
                    func(x) => format(x, '^3'),
                    range(1, w + 1)
                )
            )
        )

        buffer += '{}Flags\x1b[0m: {} \n{}\n'.format(
            FLAG_COLOR,
            self.bombsCount - len(self.flags),
            columnNumber
        )

        for (row of range(h)) {
            buffer += '   +{}\n{:>3}'.format(separator, row + 1)

            for (col of range(w)) {
                position = (col, row)

                if (position in self.dug or safe is not none) {
                    buffer += '|'

                    cell = self.board[row][col]

                    if (cell == 0)
                        buffer += '   '
                    elif (cell == 9)
                        if safe
                            buffer += ' {}F\x1b[0m '.format(FLAG_COLOR)
                        else
                            buffer += '{} * \x1b[0m'.format(BOMB_COLOR)
                    else
                        buffer += '{}{:^3}\x1b[0m'.format(ansi.acolor(CELL_COLORS[cell], ansi.BACKGROUND), cell)
                }

                elif (position in self.flags)
                    buffer += '| {}F\x1b[0m '.format(FLAG_COLOR)

                else
                    buffer += '| # '

            }

            buffer += '|{:<3}\n'.format(row + 1)
        }

        buffer += '   +{}\n{}'.format(separator, columnNumber)
        print(buffer)
    }

    # gets the position and set it as a flag on user input
    func getPositionByUser(self) {
        while true {
            result = input('Choose location (col row): ').strip()

            if (result == 'c') {
                clear()
                self.showBoard()
                continue
            }

            elif (result == 'e') {
                return false, none, none
            }

            position = result.split()
            setFlag = false

            if (len(position) == 3) {
                if (position[0].lower() == 'f')
                    position = position[1:]
                elif (position[-1].lower() == 'f')
                    position = position[:-1]
                else {
                    print('Invalid position')
                    continue
                }

                setFlag = true
            }

            elif (len(position) != 2) {
                print('Invalid position')
                continue
            }

            try {
                position = tuple(map(func(x) => int(x) - 1, position))
            }

            catch {
                print('Invalid position')
            }

            else {
                w, h = self.cellSize
                col, row = position

                if (0 <= col < w and 0 <= row < h)
                    return true, position, setFlag

                print('Invalid position')
            }
        }
    }

    # main function
    func main(self) {
        w, h = self.cellSize
        maxDug = w * h - self.bombsCount  # maximum dig that indicates finished without lose

        # create an empty board and display the board
        clear()
        self.makeNewEmptyBoard()
        self.showBoard()

        # get first position
        running, position, setFlag = self.getPositionByUser()
        if (not running)
            return;

        # make board and dig out
        self.makeNewBoard(position)
        safe = self.dig(position)

        # loop until everything has been dug up or lost
        while (len(self.dug) < maxDug and safe) {
            # show board
            self.showBoard()

            # get a position
            running, position, setFlag = self.getPositionByUser()
            if (not running)
                return;

            if setFlag
                # if setting the flag
                self.setFlag(position)
            else
                # dig
                safe = self.dig(position)
        }

        # show board and bombs
        clear()
        self.showBoard(safe=safe)

        # determine win and lose
        print(safe ? '\x1b[32mYou Win!\x1b[0m' : '\x1b[31mYou Lose!\x1b[0m')
    }

}

# wrap function

func play(cellSize=CELL_SIZE, bombsCount=BOMBS_COUNT)
    MineSweeper(cellSize, bombsCount).main()

# run the game
if (__name__ == '__main__')
    play()